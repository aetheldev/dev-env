#!/bin/bash

set -euo pipefail

STATE_FILE="/tmp/vpn-scripts-state"
OPENVPN_PROCESS="OpenVPN Connect"

# Configuration
INITIAL_DELAY=1.0        # Delay after clicking Connect before pasting
CONNECTION_TIMEOUT=5     # Max seconds to wait for connection verification
MAX_RETRIES=2           # Number of connection retry attempts

set_state() {
  echo "$1" > "$STATE_FILE"
}

get_state() {
  if [[ -f "$STATE_FILE" ]]; then
    cat "$STATE_FILE"
  else
    echo "disconnected"
  fi
}

# Check if OpenVPN Connect is running
is_openvpn_running() {
  pgrep -x "$OPENVPN_PROCESS" > /dev/null 2>&1
}

# Verify if OpenVPN is actually connected by checking system state
verify_actual_connection() {
  # VPN interfaces have IPv4 addresses, system utun interfaces only have IPv6
  local utun_with_ipv4
  utun_with_ipv4=$(ifconfig 2>/dev/null | grep -B1 'inet [0-9]' | grep -E '^utun[0-9]+:' | head -1)
  if [[ -n "$utun_with_ipv4" ]]; then
    return 0
  fi

  # Only check IPv4 routes (ignore IPv6 which system utun interfaces use)
  local ipv4_utun_routes
  ipv4_utun_routes=$(netstat -rn -f inet 2>/dev/null | awk '{print $NF}' | grep -E '^utun[0-9]+$' | head -1)
  if [[ -n "$ipv4_utun_routes" ]]; then
    return 0
  fi

  # Check if default IPv4 route goes through utun (some VPNs do this)
  local default_route
  default_route=$(netstat -rn -f inet 2>/dev/null | awk '/^default|^0\.0\.0\.0/ {print $NF; exit}')
  if [[ -n "$default_route" ]] && [[ "$default_route" =~ ^utun[0-9]+$ ]]; then
    return 0
  fi

  return 1
}

get_status() {
  local stored_state
  stored_state=$(get_state)

  # If stored state is "connected", verify it's actually connected
  if [[ "$stored_state" == "connected" ]]; then
    if ! verify_actual_connection; then
      # State file says connected but actually disconnected - update it
      set_state "disconnected"
      echo "disconnected"
      return
    fi
  fi

  # If stored state is "disconnected", also verify (to catch manual connections)
  if [[ "$stored_state" == "disconnected" ]]; then
    if verify_actual_connection; then
      # State file says disconnected but actually connected - update it
      set_state "connected"
      echo "connected"
      return
    fi
  fi

  echo "$stored_state"
}

vpn_connect() {
  # Check if OpenVPN Connect is running
  if ! is_openvpn_running; then
    echo "Error: OpenVPN Connect is not running" >&2
    return 1
  fi

  # Generate 2FA code
  local code2fa
  code2fa="2457$(2fa 'mgc')"
  
  if [[ -z "$code2fa" || ${#code2fa} -lt 4 ]]; then
    echo "Error: Failed to generate 2FA code" >&2
    return 1
  fi

  # Save current clipboard content to restore later
  local saved_clipboard
  saved_clipboard=$(pbpaste 2>/dev/null || echo "")

  # Copy 2FA code to clipboard
  echo -n "$code2fa" | pbcopy

  # Attempt connection with retry logic
  local attempt=1
  local success=false

  while [[ $attempt -le $MAX_RETRIES ]] && [[ "$success" == "false" ]]; do
    echo "Connection attempt $attempt of $MAX_RETRIES..."

    # Use AppleScript to click Connect and paste the code
    if osascript <<EOF
tell application "System Events"
  tell process "$OPENVPN_PROCESS"
    tell menu bar item 1 of menu bar 2
      click
      delay 0.3
      
      try
        click menu item "Connect" of menu 1
        delay $INITIAL_DELAY
        
        -- Paste the 2FA code from clipboard (much faster than typing)
        keystroke "v" using command down
        delay 0.2
        keystroke return
        
        return true
      on error errMsg
        -- Close menu if still open
        key code 53
        error "Failed to connect: " & errMsg
      end try
    end tell
  end tell
end tell
EOF
    then
      # Wait for connection to establish
      echo "Waiting for connection to establish..."
      local waited=0
      while [[ $waited -lt $CONNECTION_TIMEOUT ]]; do
        sleep 1
        waited=$((waited + 1))
        if verify_actual_connection; then
          success=true
          break
        fi
      done

      if [[ "$success" == "true" ]]; then
        set_state "connected"
        echo "Successfully connected to VPN"
        break
      else
        echo "Connection verification failed on attempt $attempt"
      fi
    else
      echo "AppleScript execution failed on attempt $attempt" >&2
    fi

    attempt=$((attempt + 1))
    if [[ $attempt -le $MAX_RETRIES ]] && [[ "$success" == "false" ]]; then
      echo "Retrying in 2 seconds..."
      sleep 2
    fi
  done

  # Restore original clipboard content
  echo -n "$saved_clipboard" | pbcopy 2>/dev/null || true

  if [[ "$success" == "false" ]]; then
    set_state "disconnected"
    echo "Failed to connect to VPN after $MAX_RETRIES attempts" >&2
    return 1
  fi

  return 0
}

vpn_disconnect() {
  # Check if OpenVPN Connect is running
  if ! is_openvpn_running; then
    echo "Error: OpenVPN Connect is not running" >&2
    set_state "disconnected"
    return 1
  fi

  echo "Disconnecting from VPN..."

  # Use AppleScript to click Disconnect
  if osascript <<EOF
tell application "System Events"
  tell process "$OPENVPN_PROCESS"
    tell menu bar item 1 of menu bar 2
      click
      delay 0.3
      
      try
        click menu item "Disconnect" of menu 1
        return true
      on error errMsg
        -- Close menu if still open
        key code 53
        error "Failed to disconnect: " & errMsg
      end try
    end tell
  end tell
end tell
EOF
  then
    # Wait for disconnection and verify
    echo "Waiting for disconnection..."
    local waited=0
    local max_wait=3
    while [[ $waited -lt $max_wait ]]; do
      sleep 1
      waited=$((waited + 1))
      if ! verify_actual_connection; then
        set_state "disconnected"
        echo "Successfully disconnected from VPN"
        return 0
      fi
    done

    # Still connected after timeout
    if verify_actual_connection; then
      echo "Warning: VPN still appears to be connected" >&2
      set_state "connected"
      return 1
    else
      set_state "disconnected"
      echo "Successfully disconnected from VPN"
      return 0
    fi
  else
    echo "AppleScript execution failed" >&2
    # Check actual state regardless
    if ! verify_actual_connection; then
      set_state "disconnected"
    fi
    return 1
  fi
}

show_usage() {
  cat << EOF
Usage: $0 [-c|-x|-s|-h]
  -c  Connect to VPN (with retry logic)
  -x  Disconnect from VPN
  -s  Check VPN status (verifies actual connection)
  -h  Show this help message

Environment variables (optional):
  VPN_INITIAL_DELAY      - Delay after clicking Connect (default: $INITIAL_DELAY)
  VPN_CONNECTION_TIMEOUT - Max wait time for connection (default: $CONNECTION_TIMEOUT)
  VPN_MAX_RETRIES       - Number of retry attempts (default: $MAX_RETRIES)
EOF
  exit 1
}

# Allow environment variable overrides
INITIAL_DELAY="${VPN_INITIAL_DELAY:-$INITIAL_DELAY}"
CONNECTION_TIMEOUT="${VPN_CONNECTION_TIMEOUT:-$CONNECTION_TIMEOUT}"
MAX_RETRIES="${VPN_MAX_RETRIES:-$MAX_RETRIES}"

# Main execution
case "${1:-}" in
  -c)
    vpn_connect
    exit $?
    ;;
  -x)
    vpn_disconnect
    exit $?
    ;;
  -s)
    get_status
    exit 0
    ;;
  -h|--help)
    show_usage
    ;;
  *)
    show_usage
    ;;
esac
